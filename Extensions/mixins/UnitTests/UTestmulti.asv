classdef UTestmulti < UTest
    properties (Constant)
        nestval = {[1 2 3; 4 5 6], {"A" "B" {10 20}}, 'charStr'}
        nesttyp = {["num" "cell"] ["str" "cell"] "char"}
        nested = multi(UTestmulti.nestval, UTestmulti.nesttyp)
    end
        
    properties (Constant, TestParameter)
        ref_num1 = {"1" "4" "1:end-1" ":" ""}
        ref_num2 = UTestmulti.ref_num1
        ref_num3 = UTestmulti.ref_num1
        inds_brack = {['{}' '{}', ['{}' '{}' '()']}
        ref_typ = {"num", "cell", "char", "notUsed"}
    end
    
    methods (Test)
        function ref_nums(tester, ref_num1, ref_num2, ref_num3, inds_brack)
            call1 = make_caller(ref_num1, brack_parsed, 1);
            call2 = make_caller(ref_num2, brack_parsed, 2);
            call3 = make_caller(ref_num3, brack_parsed, 3);
            caller = call1 + call2 + call3;
            [isErr, exp] = values_expect(caller);
            if isErr
                tester.verifyError(@() callMulti(caller), exp, char(caller));
            else
                actual = callMulti(caller);
                tester.verifyEqual(actual, exp, char(caller));
            end
        end
    end
end

function brack_parsed = parse_brack(inds_brack)
    brack_parsed = split(inds_brack)';
    brack_parsed = Arr.pad(brack_parsed, [1, 3 - length(brack_parsed)], "", "right");
end

function call = make_caller(ref_num, refs_bracks, pos)
    ref_brack = 
    if ref_num ~= "" && ref_brack ~= ""
        ref_brack = char(ref_brack);
        call = ref_brack(1) + ref_num + ref_brack(2);
    else
        call = "";
    end
end

function [isErr, exp] = values_expect(caller)
    if caller == ""
        exp = UTestmulti.nested;
        isErr = false;
        return
    end
    
    try 
        exp = eval("UTestmulti.nested.values" + caller);
        isErr = false;
    catch except
        exp = except.identifier;
        isErr = true;
    end
end

function actual = callMulti(caller)
    actual = eval("UTestmulti.nested" + caller);
end
